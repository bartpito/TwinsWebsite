<!DOCTYPE html></script>
<html>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
<head>
	<title>NLP</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="{{ url_for('static', filename='bootstrap/bootstrap.css') }}" rel="stylesheet" type="text/css">
	<link href="{{ url_for('static', filename='CSS/NLP.css') }}" rel="stylesheet" type="text/css">
	<script>
		$(document).ready(function(){
		// Add smooth scrolling to all links
		$("a").on('click', function(event) {
 
			// Make sure this.hash has a value before overriding default behavior
			if (this.hash !== "") {
			// Prevent default anchor click behavior
			event.preventDefault();
 
			// Store hash
			var hash = this.hash;
 
			// Using jQuery's animate() method to add smooth page scroll
			// The optional number (800) specifies the number of milliseconds it takes to scroll to the specified area
			$('html, body').animate({
				scrollTop: $(hash).offset().top
			}, 800, function(){
		
				// Add hash (#) to URL when done scrolling (default click behavior)
				window.location.hash = hash;
			});
			} // End if
		});
		});
	</script>
</head>
<body>
	<section class="app">
		<aside class="sidebar">
			<header style="font-weight: 999;" class="sidebar-navig">
				Natural Language Processing
			</header>
			<nav class="sidebar-nav">
				<ul>
					<li>
						<a href="#"><i class="ion-bag"></i> <span class="topic-decoration">&bull; Basic NLP</span></a>
						<ul class="nav-flyout">
							<li>
								<a href="#section1"><i class="ion-ios-color-filter-outline"></i>Data Augmentation</a>
							</li>
							<li>
								<a href="#section2"><i class="ion-ios-clock-outline"></i>Tokenization</a>
							</li>
							<li>
								<a href="#section3"><i class="ion-ios-color-filter-outline"></i>Text Preprocessing</a>
							</li>
						 	<li>
								<a href="#section4"><i class="ion-ios-clock-outline"></i>Regular Expressions</a>
							</li>
							<li>
								<a href="#section5"><i class="ion-ios-color-filter-outline"></i>SGD</a>
							</li>
							<li>
								<a href="#section6"><i class="ion-ios-clock-outline"></i>Logistic Regression</a>
							</li>
						</ul>
					</li>
					<li>
						<a href="#"><i class="ion-bag"></i> <span class="topic-decoration">&bull; NLTK</span></a>
						<ul class="nav-flyout">
							<li>
								<a href="#section1"><i class="ion-ios-color-filter-outline"></i>Data Augmentation</a>
							</li>
							<li>
								<a href="#section2"><i class="ion-ios-clock-outline"></i>Naive Bayes</a>
							</li>
							<li>
								<a href="#section3"><i class="ion-ios-color-filter-outline"></i>KNN</a>
							</li>
						 	<li>
								<a href="#section4"><i class="ion-ios-clock-outline"></i>SVM</a>
							</li>
							<li>
								<a href="#section5"><i class="ion-ios-color-filter-outline"></i>SGD</a>
							</li>
							<li>
								<a href="#section6"><i class="ion-ios-clock-outline"></i>Logistic Regression</a>
							</li>
						</ul>
					 </li>
					<li>
						 <a href="#"><i class="ion-bag"></i> <span class="topic-decoration">&bull; Neural Networks</span></a>
						 <ul class="nav-flyout">
							<li>
								<a href="#section11"><i class="ion-ios-clock-outline"></i>Learning process of Neural Network (NN)</a>
							</li>
							<li>
								<a href="#section12"><i class="ion-ios-color-filter-outline"></i>Keras Layers</a>
							</li>
							<li>
								<a href="#section13"><i class="ion-ios-clock-outline"></i>Convolutional NN</a>
							</li>
							<li>
								<a href="#section14"><i class="ion-ios-color-filter-outline"></i>Recurrent NN</a>
							</li>
							<li>
								<a href="#section15"><i class="ion-ios-color-filter-outline"></i>GANs</a>
							</li>
					 </ul>
					</li>
				</ul>
				<ul>
					<h2></h2>
					<li>
						<a href="{{ url_for( 'index' ) }}"><i class="ion-bag"></i> <span style="color: #00FF00">&#8227 Home Page</span></a>
					</li>
					<li>
						<a href="{{ url_for( 'about', name='pito' ) }}"><i class="ion-ios-settings"></i> <span style="color: #00FF00">&#8227 About Pito</span></a>
					</li>
					<li>
						<a href="{{ url_for( 'about', name='bart' ) }}"><i class="ion-ios-settings"></i> <span style="color: #00FF00">&#8227 About Bart</span></a>
					</li>
					<li>
						<a href="{{ url_for( 'projectsPage' ) }}"><i class="ion-ios-settings"></i> <span style="color: #00FF00">&#8227 Projects Page</span></a>
					</li>
					<li>
						<a href="{{ url_for( 'learningPage' ) }}"><i class="ion-ios-settings"></i> <span style="color: #00FF00">&#8227 Learning Page</span></a>
					</li>
				</ul>
			</nav>
		</aside>
		<div id="section1">
			<br/><a class="topic" style="text-decoration: underline;">Data Augmentation</a><br/>
			<br/><h2 class="basicText">1. Easiest Data Augmentation Techniques in Natural Language Processing:</h2>
			<p class="basicText2">
				<br/>&bull; <span style="font-weight: bold; font-size: 1.0vw;">Synonym Replacement:</span><br/> Randomly choose n words from the sentence that are not stop words. Replace each of these words with one of its synonyms chosen at random.
				<br/><br/>&bull; <span style="font-weight: bold; font-size: 1.0vw;">Random Insertion:</span> <br/>Find a random synonym of a random word in the sentence that is not a stop word. Insert that synonym into a random position in the sentence. Do this n times.
				<br/><br/>&bull; <span style="font-weight: bold; font-size: 1.0vw;">Random Swap:</span> <br/>Randomly choose two words in the sentence and swap their positions. Do this n times.
				<br/><br/>&bull; <span style="font-weight: bold; font-size: 1.0vw;">Random Deletion:</span> <br/>Randomly remove each word in the sentence with probability p.
				<br/><br/><a href="https://github.com/jasonwei20/eda_nlp/blob/master/code/eda.py" style="font-weight: bold; text-decoration: underline; color: black; font-size: 1.2vw;">Code Implementation</a>
			</p>
		</div>
		<div id="section2">
			<br/><a class="topic" style="text-decoration: underline;">Tokenization</a><br/>
			<br/><h2 class="basicText">1. Description:</h2>
			<p class="basicText2">
				<br/>&bull; <span style="font-weight: bold; font-size: 1.0vw;">The process of segmenting running text into words and sentences.</span>
				Electronic text is a linear sequence of symbols (characters or words or phrases). Naturally, before any real text processing is to be done, text needs to be segmented into linguistic units such as words, punctuation, numbers, alpha-numerics, etc. This process is called tokenization.
				In English, words are often separated from each other by blanks (white space), but not all white space is equal. Both “Los Angeles” and “rock 'n' roll” are individual thoughts despite the fact that they contain multiple words and spaces. We may also need to separate single words like “I'm” into separate words “I” and “am”.
				Tokenization is a kind of pre-processing in a sense; an identification of basic units to be processed. It is conventional to concentrate on pure analysis or generation while taking basic units for granted. Yet without these basic units clearly segregated it is impossible to carry out any analysis or generation.
				The identification of units that do not need to be further decomposed for subsequent processing is an extremely important one. Errors made at this stage are very likely to induce more errors at later stages of text processing and are therefore very dangerous.
				<br/><br/><br/>&bull; <span style="font-weight: bold; font-size: 1.0vw;">More information can be found at this link:</span>
				<br/><br/><a href="https://www.ibm.com/developerworks/community/blogs/nlp/entry/tokenization?lang=en" style="font-weight: bold; text-decoration: underline; color: black; font-size: 1.2vw;">The Art of Tokenization</a>
			</p>
		</div>
		<div id="section3">
			<br/><a class="topic" style="text-decoration: underline;">Text Preprocessing:</a><br/>
			<br/><h2 class="basicText">What is text preprocessing?</h2>
			<p class="basicText2">
				<br/>&bull; To preprocess your text simply means to bring your text into a form that is <span style="font-weight: bold; font-size: 1.0vw;">predictable</span> and <span style="font-weight: bold; font-size: 1.0vw;">analyzable</span> for your task. A task here is a combination of approach and domain. For example, extracting 
				top keywords with TF-IDF (approach) from Tweets (domain) is an example of a Task.
			</p>
			<br/><h2 class="basicText">Types of text preprocessing techniques:</h2>
			<p class="basicText2">
				<span style="font-weight: bold; font-size: 1.1vw;">&bull; Lowercasing</span>
				<br/>Lowercasing ALL your text data, although commonly overlooked, is one of the simplest and most effective form of text preprocessing. It is applicable to most text mining and NLP problems and can help in cases where your dataset is not very large and significantly helps with consistency of expected output.
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw;">&bull; Stemming</span>
				<br/>Stemming is the process of reducing inflection in words (e.g. troubled, troubles) to their root form (e.g. trouble). The “root” in this case may not be a real root word, but just a canonical form of the original word.
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw;">&bull; Lemmatization</span>
				<br/>Lemmatization on the surface is very similar to stemming, where the goal is to remove inflections and map a word to its root form. The only difference is that, lemmatization tries to do it the proper way. It doesn’t just chop things off, it actually transforms words to the actual root. For example, the word “better”
				would map to “good”. It may use a dictionary such as WordNet for mappings or some special rule-based approaches.
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw;">&bull; Stopword Removal</span>
				<br/>Stop words are a set of commonly used words in a language. Examples of stop words in English are “a”, “the”, “is”, “are” and etc. The intuition behind using stop words is that, by removing low information words from text, we can focus on the important words instead.
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw;">&bull; Normalization</span>
				<br/>A highly overlooked preprocessing step is text normalization. Text normalization is the process of transforming a text into a canonical (standard) form. For example, the word “gooood” and “gud” can be transformed to “good”, its canonical form. Another example is mapping of near identical words such as “stopwords”, 
				“stop-words” and “stop words” to just “stopwords”.
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw;">&bull; Noise Removal</span>
				<br/>Noise removal is about removing characters digits and pieces of text that can interfere with your text analysis. Noise removal is one of the most essential text preprocessing steps. It is also highly domain dependent.
				<br/><br/>For example, in Tweets, noise could be all special characters except hashtags as it signifies concepts that can characterize a Tweet. The problem with noise is that it can produce results that are inconsistent in your downstream tasks.
				<br/><br/><br/>&bull; <span style="font-weight: bold; font-size: 1.1vw;">More information can be found at this link:</span>
				<br/><br/><a href="https://www.kdnuggets.com/2019/04/text-preprocessing-nlp-machine-learning.html" style="font-weight: bold; text-decoration: underline; color: black; font-size: 1.2vw;">All you need to know about text preprocessing for NLP and Machine Learning</a>
			</p>
		</div>
		<div id="section4">
			<br/><a class="topic" style="text-decoration: underline;">Regular Expressions:</a><br/>
			<br/><h2 class="basicText">Basic Topics:</h2>
			<p class="basicText2">
				<br/><span style="font-weight: bold; font-size: 1.2vw;">Anchors:&nbsp;&nbsp;  ^ and $  </span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">^The</span>matches any string that starts with The
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">end$</span>matches a string that ends with end
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">^The end$</span>exact string match (starts and ends with The end)
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">roar</span>matches any string that has the text roar in it
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Quantifiers:&nbsp;&nbsp; * + ? and {} </span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">abc*</span>matches a string that has ab followed by zero or more c
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">abc+</span>matches a string that has ab followed by one or more c
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">abc?</span>matches a string that has ab followed by zero or one c
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">abc{2}</span>matches a string that has ab followed by 2 c
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">abc{2,}</span>matches a string that has ab followed by 2 or more c
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">abc{2,5}</span>matches a string that has ab followed by 2 up to 5 c
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">a(bc)*</span>matches a string that has a followed by zero or more copies of the sequence bc
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">a(bc){2,5}</span>matches a string that has a followed by 2 up to 5 copies of the sequence bc
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">OR operator:&nbsp;&nbsp; | or [] </span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">a(b|c)</span>matches a string that has a followed by b or c
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">a[bc]</span>same as previous
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Character Classes:&nbsp;&nbsp;  \d \w \s and .</span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\d</span>matches a single character that is a digit
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\w</span>matches a word character (alphanumeric character plus underscore)
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\s</span>matches a whitespace character (includes tabs and line breaks)
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">.</span>matches any character
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\D</span>matches a single non-digit character
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\W</span>matches any non-word character (equal to [^a-zA-Z0-9_])
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\S</span>matches any non-whitespace character (equal to [^\r\n\t\f\v ])
				<br/><br/><span style="font-weight: bold; font-size: 1.0vw; padding-right: 5em; margin-left:2%;">In order to be taken literally, you must escape the characters ^.[$()|*+?{\with a backslash \ as they have special meaning.</span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\$\d:&nbsp;&nbsp;</span>matches a string that has a $ before one digit
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Flags </span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">g</span>(global) does not return after the first match, restarting the subsequent searches from the end of the previous match
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">m</span>(multi-line) when enabled ^ and $ will match the start and end of a line, instead of the whole string
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">i</span>(insensitive) makes the whole expression case-insensitive (for instance /aBc/i would match AbC)
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Grouping and Capturing:&nbsp;&nbsp; () </span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">a(bc)</span>parentheses create a capturing group with value bc
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">a(?:bc)*</span>using ?: we disable the capturing group
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">a(?<foo>bc)</span>using ?<foo> we put a name to the group
			</p>
			<p class="basicText2">
				<br/><span style="font-weight: bold; font-size: 1.2vw;">Bracket Expressions:&nbsp;&nbsp;  []</span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">[abc]</span>matches a string that has either an a or a b or a c 
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">[a-c]</span>same as previous
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">[a-fA-F0-9]</span>a string that represents a single hexadecimal digit, case insensitively
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">[0-9]%</span>a string that has a character from 0 to 9 before a % sign
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">[^a-zA-Z]</span>a string that has not a letter from a to z or from A to Z. In this case the ^ is used as negation of the expression
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">Remember that inside bracket expressions all special characters (including the backslash \) lose their special powers: thus we will not apply the “escape rule”.</span>
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Greedy and Lazy match:</span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;"><.+?></span> matches any character one or more times included inside < and >, expanding as needed
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;"><[^<>]+> =</span>matches any character except < or > one or more times included inside < and >
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Boundaries:&nbsp;&nbsp;  \b and \B</span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\babc\b</span> performs a "whole words only"</and>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">\Babc\B</span>matches only if the pattern is fully surrounded by word characters
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Back-references:&nbsp;&nbsp; \1 </span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">([abc])\1</span> using \1 it matches the same text that was matched by the first capturing group
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">([abc])([de])\2\1 </span> we can use \2 (\3, \4, etc.) to identify the same text that was matched by the second (third, fourth, etc.) capturing group
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">(?<foo>[abc])\k<foo></foo></span>we put the name foo to the group and we reference it later (\k<foo>). The result is the same of the first regex
			</p>
			<p class="basicText2">
				<br/><br/><span style="font-weight: bold; font-size: 1.2vw;">Look-ahead and Look-behind:&nbsp;&nbsp; (?=) and (?<=) </span>
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">d(?=r)</span>matches a d only if is followed by r, but r will not be part of the overall regex match
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">(?<=r)d</span>matches a d only if is preceded by an r, but r will not be part of the overall regex match
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">d(?!r)</span>matches a d only if is not followed by r, but r will not be part of the overall regex match
				<br/><br/><span style="font-weight: bold; font-size: 1.1vw; padding-right: 5em; margin-left:2%;">(?<!r)d</span>matches a d only if is not preceded by an r, but r will not be part of the overall regex match
			</p>
	</section>
</body>
</html>